# single-spa微前端框架
## 辅助
- 辅助方法：app.helpers.js中定义了子应用的状态：加载、启动、挂载、卸载。
- 并有一个**分类函数**根据状态对各个子应用分类。

## 基础
- 核心两个函数，registerApplication和start，在single-spa.js中对外暴露。
1. register注册应用时候，如果路径匹配，会加载对应的应用；不匹配则不会加载。
2. start启动后，会加载路径匹配的应用 =》 启动对应的应用 =》确保卸载完应用 =》 挂载应用。
<!--
 start的加载应用是因为注册时候可能没加载当前路径的应用，那就再加载一次。
    比如注册应用时候是路径/a，会加载a应用，但不会加载b应用。
    启动时候是b应用，这时候需要加载b应用。
 -->
## registerApplication
1. app.js中暴露此方法，接受应用注册的数据，所有子应用统一放到apps；
2. 每注册一个应用，调用一次reroute方法。

## start
1. started全局变量，确保只加载一次。
2. 调用reroute方法。

## 核心：***reroute***方法
<!-- 做两件事情，一个是分类函数，另一个是根据是否开启来加载、启动、挂载、卸载应用 -->
1. 根据应用的state状态区分要加载的应用、要卸载的应用、要挂载的应用。
然后根据全局started变量两种情况：
2. 一种是没有调用start方法，用户注册时候调用reroute方法，只会加载当前路径匹配、对应的应用。
3. 第二种情况是调用了start方法，用户会卸载应用，
加载对应的应用 =》 启动对应的应用 =》 确保卸载完毕 =》 挂载对应的应用。

## 生命周期方法
<!-- lifecycles下的四个文件 -->
- 加载逻辑：把子应用暴露的接口协议放到子应用实例上。
- 启动、挂载、卸载：就是按序调用对应的接口协议。

## 路由监听
<!-- single-spa\navigation\navigation-event.js -->
- single-spa会开启监听hashchange、popstate事件，如果触发了执行reroute函数（也就是 调用分类函数，加载、启动、挂载、卸载的逻辑）。
- 子应用也有路由系统（比如：vue-router）监听hashchange、popstate事件，需要在子应用加载完毕后执行。
我们要对addEventListener进行重写：如果是hashchange、popstate则不执行，添加到一个任务队列中保存，其他正常执行。在reroute里面，等挂载的promise执行完毕后执行子应用的监听事件。

# 面试回答
- 辅助文件 =》 register、start =》 reroute、接入协议 =》 路由监听。
1. 首先可以明确几个概念，在一个辅助文件中定义每个子应用状态：加载、启动、挂载、卸载。然后定义一个分类函数：根据子应用状态，分为要加载的数组、要挂载的数组、要卸载的数组。

2. 我们在使用框架时候核心是两个函数：register和start方法，这两个方法都会调用reroute方法，reroute方法是整个微前端框架的核心。

3. 在reroute里，主要做两件事情。第一是会调用我们的分类函数，区分哪些应用要加载、哪些要挂载卸载。第二是根据全局变量判断是否调用了start方法，
如果没调用start方法的话，只会加载应用，不走启动挂载流程。
如果调用了start方法，则会加载、启动、挂载、卸载整套流程。
加载的话其实是我们去加载子应用的入口文件，把接入协议放到我们子应用实例上。启动、挂载、卸载就是调用对应接入协议。

4. 路由监听：会监听hashchange、popstate两个事件，调用reroute事件。
这里有一个重点要考虑，子应用也会有路由系统监听事件比如vue-router，我们需要等子应用加载挂载完毕后再去执行子应用的路由事件。这里会对addEventListener进行重写，如果是hashchange、popstate事件，不会直接执行而是保留到任务队列中，等在reroute里面挂载完毕应用后再去执行。

